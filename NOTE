SOAR:
    Решетка. Количество вакантных мест изменяется. Подаются вакантные места в формате: робот-цель + место относительно него + положение относительно него + расстояние. 
    ПРОБЛЕМА Тогда как происходит процесс принятия решения? Если каждый робот должен изолированно сам принимать решения, как разрешать проблему что два робота могут нацелиться на одно место. 
    1 Можно сделать двухэтапно? Каждый робот выдает свою цель и другой скрипт Соар распределяет места, тогда пропадает децентрализованность.
    2 Исключить одинаковые цели на внешнем этапе. У роботов не может быть пересечений в вариантах целей поданных в Соар. Вроде подходит. Реализвация: робот транслирует вакантные места у себя и... и откликаться должен уже более менее достойный кандидат. Заносить в Соар вакантные места?
    Получается неправильный формат входных изначально.
    НОВОЕ: Вакантные места (все) подаются в ядро Соар одного агента. Выбирает цель, если условия благоприятные для двух целей происходит рандом. 
    ПРОБЛЕМА: может занять место благоприятное для другого, может быть для него вообще не было хорошего варианта а он уже что-то занял. 
    РЕШЕНИЕ: Делать цикл по роботам? Просто двинуться в сторону решетки. Сделать маленькое смещение и снова подумать? Ждать..? Так в этой модели ядро Соар одно, нет параллельности, да? Последовательно принимаются решения. На практике должно быть одновременно тогда ожидание? Нет плохо, чего ждать? А в модели как? 
        ПОДРЕШЕНИЕ: В случае модели. Нет хорошего варианта двинуться в сторону лидера?
    СЛУЧАЙ: Вакантное место - Справа от лидера.
    Есть робот 1 - лидер для него слева далеко.
    Есть робот 2 - лидер для него слева близко.
    Понятно что 1 выгоднее, но 2 нужно туда же. Все кто далеко просто сбиваются в кучу??? 
    
#state robots with neiborhood (all or with valence)? operators are valences. action: state change by deleting not need operators?
# preferences??? need to chose single operator: return one valence. equal operators are choosing randomly
# stay is the operator?? the worst one
# По вводу связанных данных: можно, например, добавить к одной входной переменной несколько отношений, описывающих вакантное место: <place> ^type place, <place> ^near robot1, <place> ^position right, а к другой --- описывающих каждого робота: <robotA> ^type robot, <robotA> ^name robot1, <robotA> ^relative-position to-left-from-us, <robotA> ^distance-from-you far. Связывание этих отношений делается в условии правила, которое заставляет нашего робота двигаться в указанное место.


    def CreateStringWME(self, pAttribute, pValue):
        return _Python_sml_ClientInterface.Identifier_CreateStringWME(self, pAttribute, pValue)

    def CreateIntWME(self, pAttribute, value):
        return _Python_sml_ClientInterface.Identifier_CreateIntWME(self, pAttribute, value)

    def CreateFloatWME(self, pAttribute, value):
        return _Python_sml_ClientInterface.Identifier_CreateFloatWME(self, pAttribute, value)

    def CreateIdWME(self, pAttribute):
        return _Python_sml_ClientInterface.Identifier_CreateIdWME(self, pAttribute)

    def CreateSharedIdWME(self, pAttribute, pSharedValue):
        return _Python_sml_ClientInterface.Identifier_CreateSharedIdWME(self, pAttribute, pSharedValue)    

        
        
ОПИСАНИЕ АЛГОРИТМА
1. Определение лидера (произвольно) 
/ robot1

2. Лидер посылает свои вакантные места (в зависимости от вида строя) 
/ 'left', 'right', 'back' 
соседям всем (близлежащим, в зависимости от типа передаваемого сигнала, каким устройством). 
Ждет ответов 
/ lt,rt,bk = ''.

3. Каждый сосед анализирует, вакантные места и отвечает лидеру
Массив вакантных мест из него берет места и имя робота 
/ free_places[]
Для лидера с местами строится soar_sentence у каждого робота, два слова
/ input_link-- ^nearby-- r--        ^name-- 'r1' 
                                    ^place-- 'left'
                                    ^place-- 'right'
                                    ^place-- 'back'
                                    ^dir-- 'back' себя относительно него 

?возможно ли сделать три категории расстояния – далеко, средне, близко?
?информация только о положении робота с вакантным(и) местом(ами). в перспективе нужно знать расположение всех, чтобы например избегать столкновений или иметь возможность выстраиваться в решетку локально?

1) те, кто далеко просто движутся в направлении лидера как при сбивании в кучу
если есть хоть одно место у дальнего робота добавляем его в go-to
/ input_link-- ^away-- r--      ^name-- 'r1'
                                ^place-- 'left' 
                                ^dir-- 'back'
и можно начинать двигаться в его сторону независимо от решений остальных роботов
2) те, кто близко анализируют удобное для них место, в go-to добавляются все места относительно лидера(лидеров, когда несколько роботов уже стоит в решетке) формат: имя+место, исходя из их положения относительно лидера, посылают ответ в формате: “хочу встать справа”. 
/ r1-- right

?можно ли чтобы соар выдавал несколько подходящих целей одному роботу, то есть возможность посылать несколько запросов, а уже лидер анализировал давать ему какое-либо место или нет. таким образом увеличивается шанс получить команду к движению. повышается эффективность?

4. Лидер анализирует полученные ответы.
0) далекие могут двигаться
1) если претендент на место один – лидер дает ему сигнал двигаться к этому месту и помечает данное место зарезервированным
/ rt = 'r3'; 'left', 'back' остаются 
2) если претендентов несколько – лидер анализирует, кто из них больше подходит, 
/ soar_sentences претендентов и их запрос
дает сигнал двигаться к этому месту и помечает данное место зарезервированным. Остальным претендентам дает команду стоять на месте (ИЛИ претенденты просто получают ответ да или нет от лидера – одобрение заявки, если заявка не одобрена стоим на месте)

?Как определяется, что робот достиг и занял предполагаемое место?

5. Повторение алгоритма. 
Робот, который занимает место в решетке теперь имеет вакантные места возле себя и посылает об этом сигнал соседям, то есть действует как лидер. А остальные (рассматривают) обрабатывают все вакантные места одновременно. Пока не закончатся роботы без мест.
