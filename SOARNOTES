Soar ЗАМЕТКИ

Создание элементов рабочей памяти:
1. Продукции. Действия RHS?
2. Архитектура. а)описания состояния б)описания оператора
3. Системы памяти
4. SVS
5. Окружение. Внешние входы/выходы

Удаление элементов рабочей памяти:
1. Процедурой решения - все описания состояния после разрешения тупика, для которого они были созданы
2. Процедурой решения - удаляет описания оператора о состоянии, когда он перестает быть текущим
3. reject?
4. Архитектурой - i-supported ЭРП (поддерживаемые экземпляром)
5. Вход/выход системой - неактуальные данные из input-link
6. Архитектурой - не связанные с состоянием ЭРПы

English
augmentation - дополнение
instantiation - экземпляр

Продукция = условия + действия. Если условия = рабочей памяти -- продукция включается и выполняются действия. Порядок условий не важен (только первое условие должно явно проверять состояние). Экземпляры продукции создаются при использовании переменных.
Функции продукций: 1. Предложение оператора 2. Сравнение оператора 3. Применение оператора 4. Развитие(изменение) состояния
В основном действия продукции это - создание предпочтений или создание/удаление ЭРПов.

Память предпочтений. Предпочтения ссылаются на операторы, так выбирается текущий оператор. Единственное значение может быть выбрано текущим оператором. У предпочтений нет транзитивности. Когда два и более значения равнопредпочтительны Соар выбирает рандомно, это можно изменить decide indifferent-selection функцией. 

Блоки в коде Соар делятся на два типа: с оператором в условии и без. Те что без могут автоматически отзывать действия, когда условия перестают выполняться. i-supported and o-supported? Те что с оператором выполняются только одно за раз, если их несколько.

Цикл выполнения в соар (цикл принятия решения):
1. Вход. Получение новых данных с сенсоров в рабочую память (входные функции)
2. Предложение. Продукции выполняются(откатываются), выдвигают в кандидаты операторы и сравнивают их. i-supported(удаляются если продукция перестает быть актуальной (отзываются автоматически)). Так до установления равновесия (ни одна продукция не дает совпадение).
3. Решение. Выбран новый оператор или создано новое состояние, если тупик. 
4. Приложение.(Выполнение.) Выполняются продукции с оператором в условии. o-supported(удаляются в ручную, иначе остаются в рабочей памяти). После этого блоки без операторов обрабатываются до момента равновесия.
5. Выход. Выходные команды отправляются во внешний мир. (выходные функции)

Soar
    while (HALT not true) Cycle;

Cycle
    InputPhase;
    ProposalPhase;
    DecisionPhase;
    ApplicationPhase;
    OutputPhase;

ProposalPhase
    while (some i-supported productions are waiting to fire or retract)
        FireNewlyMatchedProductions;
        RetractNewlyUnmatchedProductions;

DecisionPhase
    for (each state in the stack, starting with the top-level state)
    until (a new decision is reached)
        EvaluateOperatorPreferences; /* for the state being considered */
        if (one operator preferred after preference evaluation)
            SelectNewOperator;
        else /* could be no operator available or */
            CreateNewSubstate; /* unable to decide between more than one */
ApplicationPhase
    while (some productions are waiting to fire or retract)
        FireNewlyMatchedProductions;
        RetractNewlyUnmatchedProductions;

Тупики возникают, когда не получается выбрать один оператор, те есть противоречия и прочее. Для решения тупиков создаются подсостояния их может быть много. Результат решения тупика тоже может быть и или о саппортед. Это определяется рассуждением.
Создается временная продукция - рассуждение. Ее условия - это все условия(ЭРПы) всех срабатываемых в подсостоянии(подцели) продукций для получения результата. Ее действие - результат подцели. И определение типа происходит как для любой другой продукции, в зависимости от наличия оператора
Chunking (деление, кусочничество)
Чанкинг - обучающий механизм Соар, создание новой продукции - чанк. Для предупреждения тупиков в похожих ситуациях. Рассуждение исчезает когда условия не соответствуют, а чанк содержит переменные то есть могут подходить к другим похожим ситуациям.

СИНТАКСИС
Элемент рабочей памяти (ЭРП): (id ^attribute value). Набор ЭРПов с одним id - объект. Аттрибуты могут быть однозначными.
(identifier ^operator value +) доступные предпочтения (acceptable preferences), если без + то это просто оператор 
Рабочая память - не просто множество, а граф, не произвольный а дерево с корнем состояние(стэйт). Айдишники - узлы, аттрибуты - ребро, константы - конечные узлы(листы).
sp {production-name
"Documentation string"
:type
CONDITIONS
-->
ACTIONS
}
Верхняя часть продукции в Соар - условие:
(identifier-test ^attribute1-test value1-test
                ^attribute2-test value2-test
                ^attribute3-test value3-test
...)
<...> - переменная. <<..>> - дизъюнкция, проверяет чтобы было равно одному из значений в скобках
{...} - конъюнкция, проверка нескольких условий чтобы выполнялись все 
Примеры: то есть идет проверка и помещение в переменную одновременно
{ <x> > <y> } - значение помещается в переменную х и должно быть больше чем у
{ <> <x> <y> } и { <y> <> <x> } - значение в перем у и не равно х
{ <=> <x> > <y> << 1 2 3 4 >> <z> } - тот же тип что и значение в переменной х, больше знач в у, равно одному из 4х значений, помещается в z
-(<p1> ^type father) - отсутствие данного ЭРПа
(<p1> ^name john -^type father ^spouse <p2>) - сработает если есть ЭРП первый и третий и нет второго с тем же айдишником
Нельзя ставить негативное условие в продукции i-support (без оператора) в итоге которого потом это условие перестает выполняться (создается ЭРП, отсутствие которого проверяется == бесконечный цикл) и нельзя ставить его первым 
(state <s> -^road <r>
^car <c>)
(state <s> -^road <r>
^car <c>)
Можно сгруппировать негативный тест нескольких ЭРПов
sp {blocks*negated-conjunction-example
(state <s> ^name top-state)
    -{(<s> ^ontop <on>)
    (<on> ^bottom-object <bo>)
    (<bo> ^type table)}
-->
(<s> ^nothing-ontop-table true) }

¬(A ∧ B ∧ C) соответствует (¬A) ∨ (¬B) ∨ (¬C)
(<p1> ^type father ^child <c1> <c2>) - проверка что <p1> имеет две переменных к атрибуту ^child (но они могут иметь одинаковое значение значение)
(<p1> ^type father ^child ?[<c1>]? {<> <c1> <c2>}) - так корректнее, проверяем что <c2> связан с иным значением чем <c1>
(<p1> ^name john)
-{(<p1> ^child oprah)
(<p1> ^child uma)} -- проверка что нет первого ребенка или другого связанного с <p1>, но не срабатывает если оба есть

sp {blocks*example-production-conditions
(state <s> ^operator <o> +
            ^thing <t> {<> <t> <t2>} )
(operator <o> ^name group
            ^by-attribute <a>
            ^moving-block <t>
            ^destination <t2>)
(<t> ^type block ^<a> <x>)
(<t2> ^type block ^<a> <x>)
-->
(<s> ^operator <o> >) } -- "+" проверяет что есть оператор кандидат (добавляет предпочтение "доступен" к нему? но это не проверяет что данный оператор выбран текущим) - позволяет создать предпочтение для него до выбора. идет проверка что есть оператор группирующий по атрибуту содерж в переменной <a> и что <t> and <t2> имеют этот атрибут с одинаковым значением.
??Acceptable preferences for operators can be matched in a condition by testing for a “+”??

sp {blocks*example-production-conditions
(state ^operator <o> + ^table <t>)
(<t> ^<> type table)
-->
... } -- проверяет что объект привязанный к переменной <t> имеет атрибут со значением table но название этого атрибута не type

sp {blocks*example-production-conditions
(state ^operator <o> + ^table <t>)
(<t> ^<< type name>> table)
-->
... } --  <t> имеет либо аттрибут тип либо аттрибут имя равный столу

sp {blocks*example-production-conditions
(state ^operator <o> + ^table <t>)
(<t> ^{<ta> <> name} table)
-->
... } -- конъюктивный тест для атрибута. имя атрибута в переменной <ta>, не равно name и значение его table

